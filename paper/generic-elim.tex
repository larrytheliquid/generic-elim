\documentclass[preprint,nonatbib]{sigplanconf}
\usepackage[authoryear,square]{natbib}

\usepackage{todonotes}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{url}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{stmaryrd}
\usepackage{enumitem}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{8759}{\ensuremath{\colon\colon}}
\DeclareUnicodeCharacter{12314}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{12315}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{8614}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{?}{=}}}

\DeclareUnicodeCharacter{7496}{\ensuremath{^{d}}}

\usepackage{fancyvrb}

\usepackage[labelfont=bf]{caption}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\titlebanner{DRAFT}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic Eliminators from Descriptions}
\subtitle{Dependently typed programming without the algebra}

\authorinfo{Larry Diehl\and Tim Sheard}
           {Portland State University}

\maketitle

\begin{abstract}
Sed pellentesque massa purus, ac aliquam ipsum auctor in. Mauris et
libero risus. In scelerisque neque vel odio tempus, commodo gravida
purus faucibus. Aliquam pharetra mauris consequat, gravida justo sed,
facilisis elit. Nullam enim ipsum, varius ut condimentum eget, tempor
id eros. Aenean id eros vestibulum, hendrerit dui eget, tincidunt
elit. Ut nec dignissim lectus, a bibendum turpis. Vivamus tincidunt
consequat ante. Suspendisse congue convallis ipsum vitae egestas. Ut
interdum elit id nunc aliquam lobortis.
\end{abstract}

\category{D.3}{Software}{Programming Languages}.

\keywords
Generic programming; dependent types; descriptions; eliminators.

\section{Introduction}
\label{sec:intro}

Descriptions make datatype definitions first class values in a
dependent type theory. This has several desirable consequences, such as the
ability to perform generic programming~\citep{Chapman:2010:GAL:1932681.1863547,mcbride2010ornamental,dagand:phd}
over described types, as well as decreasing the number of constructs in the
metatheory via levitation~\citep{Chapman:2010:GAL:1932681.1863547,dagand:phd}. 
Any type represented as a description can
be eliminated with its elimination rule -- called {\tt ind} -- which resembles a fold (or catamorphism) but
over indexed type families. Functions written with {\tt ind} are
verbose but follow a recognizable pattern (Section \ref{sec:ind}). 
On the other hand, functions written with standard {\it eliminators} (or
induction principles) are shorter and more widely understood.

Now let's look at the type of {\tt ind}. Think of it almost like a standard
eliminator that has been parameterized over any description {\tt D} of a type. The
motive {\tt P} is indexed over the type family {\tt μ I D i}, which is
the datatype that description {\tt D} represents.
Here {\tt I} is the type of the index of the type family being
encoded, and {\tt i} is the value of the index whose type is {\tt I}.
The key difference
between {\tt ind} and a standard eliminator is that all branches for
each constructor of the encoded type are packaged into a single branch
{\tt α}. In order to prove that {\tt P} holds for any
{\tt μ I D i}, you get all constructors and all of their
arguments in {\tt xs}, along with all inductive
hypotheses {\tt ihs} for any recursive constructor arguments.

\newpage

\begin{verbatim}
ind : {I : Set}
  (D : Desc I)
  (P : (i : I) → μ D i → Set)
  (α : Hyps D X P ⇒ P ∘ init)
  (i : I) (x : μ D i) → P i x
\end{verbatim}

Function definitions written with {\tt ind} are verbose
because they need to unpack all of the data supplied by {\tt α}.
Worse still, there are several ways to define the datatype of
descriptions {\tt Desc}, and several ways to encode datatypes once a
particular definition of {\tt Desc} has been chosen. This means that a
user wishing to program with datatypes encoded by descriptions must be
aware of how the encodings get interpreted so that they may
appropriately unpack data when writing functions with {\tt ind}.

For example, if we partially apply {\tt ind} to a description of a
vector of booleans {\tt ind ℕ (VecD Bool)} then the type of the
resulting expression depends both on how we defined {\tt Desc} and how
we encoded vectors as a description {\tt VecD}.

Rather than making the user learn our data format and suffer the
consequences of unpacking encoded data, our {\bf primary contribution} is
the definition of a {\it generic} eliminator {\tt elim}!
It assumes a particular way of encoding
datatypes via descriptions, and partial application of such a
description to {\tt elim} results in the expected type of eliminator.
For example, partial application of our previous example to
{\tt elim} results in the following type.

\begin{verbatim}
elim ℕ (VecD Bool) :
  (P : (n : ℕ) → Vec Bool n → Set)
  (pnil : P zero nil)
  (pcons : (n : ℕ) (x : Bool) (xs : Vec Bool n)
    → P n xs → P (suc n) (cons n x xs))
  (n : ℕ) (xs : Vec Bool n) → P n xs
\end{verbatim}

Our {\tt elim} function can be defined in terms of
{\tt ind}, making it another example of generic programming made
possible by descriptions.
Note that we are not generating specialized eliminators like
{\tt elimVec} à la {\sc Coq}, but instead have a single generic
{\tt elim} function that can be applied to any description of a
datatype.
Because this definition is internal to the
existing type theory, no additional metatheory needs to be proven.
Furthermore, there are several existing algorithms already defined in
terms of eliminators that can now be reused.
For example, \citet{gimenez1995codifying} translates
{\sc Coq}~\citeyearpar{coq08} {\tt Fix}-based definitions into eliminators,
and \citet{Goguen06eliminatingdependent} and
\citet{McBride:2000:EM:646540.759262}
translate dependent pattern matching into
eliminators. Rather than reinventing these algorithms to translate to
{\tt ind}, we can instead directly reuse them with our derived {\tt elim}.

\section{Background}
\label{sec:background}

We will begin with a review of the framework used to encode datatypes
via descriptions. There are
several ways to define the datatype of descriptions {\tt Desc}. 
For simplicity, in this paper we use the encoding by
\citet{mcbride2010ornamental}.

\subsection{The Type of Descriptions}

The datatype {\tt Desc} of descriptions is used to represent
user-defined definitions of strictly-positive indexed
families of inductively defined types.
{\tt Desc} is paramterized by 
a type {\tt I}, the index of the encoded type family.

Let's first think about how to use {\tt Desc} to encode a single
constructor of an indexed type family.
A constructor is a sequence of
arguments that subsequent arguments may depend on, along with
recursive arguments at some type indices, and ends with some type index.
Respectively, {\tt Arg}, {\tt Rec}, and {\tt End} allow you to encode
a dependent argument, a recursive argument at some index, and ending the
constructor at some index.

\begin{verbatim}
data Desc (I : Set) : Set₁ where
  End : (i : I) → Desc I
  Rec : (i : I) (D : Desc I) → Desc I
  Arg : (A : Set) (B : A → Desc I) → Desc I
\end{verbatim}

\subsection{Describing a Single Constructor}

For example, first recall the standard type of the
constructor {\tt cons} of vectors.

\begin{verbatim}
cons : (n : ℕ) → A → Vec A n → Vec A (suc n)
\end{verbatim}

We can encode the type of this constructor as a description as
follows. The definition is parameterized by the vector parameter
type {\tt A}, and returns a description over natural numbers
{\tt Desc ℕ} because the type we are encoding {\tt Vec}
is indexed by natural numbers.

\begin{verbatim}
consD : (A : Set) → Desc ℕ
consD A =
  Arg ℕ (λ n → Arg A (λ _ → Rec n (End (suc n))))
\end{verbatim}

\subsection{Describing Multiple Constructors}

The datatype {\tt Desc} can also be used to describe an entire
datatype, consisting of descriptions of multiple constructors.
This is achieved by making use of the isomorphism between disjoint
sums and dependent pairs whose domain is some finite enumeration.

A datatype with multiple constructors is represented by an
{\tt Arg} description whose first argument is a datatype of tags
-- one for each constructor -- and whose second argument is
a function that returns a description for each constructor tag.

\begin{verbatim}
data VecT : Set where
  nilT consT : VecT

VecC : (A : Set) → VecT → Desc ℕ
VecC A nilT = End zero
VecC A consT =
  Arg ℕ (λ n → Arg A (λ _ → Rec n (End (suc n))))

VecD : (A : Set) → Desc ℕ
VecD A = Arg VecT (VecC A)
\end{verbatim}

Notice that our previous description of the {\tt cons} constructor,
{\tt consD A}, is equal to the tagged description
{\tt VecC A consT}.

\subsection{Datatypes from Descriptions}

Now that we can encode datatypes as descriptions, we will see how to
convert a description into a full datatype. You get such a datatype by
applying the fixpoint type {\tt μ} to a description.
The constructor {\tt init}
for {\tt μ} is the initial algebra of the description interpreted as
an endofunctor on indexed families of sets.

\begin{verbatim}
data μ {I : Set} (D : Desc I) (i : I) : Set where
  init : El D (μ D) i → μ D i
\end{verbatim}

For example, we can define the datatype {\tt Vec} by applying
{\tt μ} to its description.

\begin{verbatim}
Vec : (A : Set) (n : ℕ) → Set
Vec A n = μ (VecD A) n
\end{verbatim}

\subsection{Endofunctors from Descriptions}

The constructor for {\tt μ} takes an argument of type {\tt El}.
This is a function that when given a description computes an
endofunctor between type families. Below, {\tt ISet} is the type of
type families, and {\tt IFunc} is the endofunctor type.

\begin{verbatim}
ISet : Set → Set₁
ISet I = I → Set

IFunc : Set → Set₁
IFunc I = ISet I → ISet I

El : {I : Set} (D : Desc I) → IFunc I
El (End j) X i = j ≡ i
El (Rec j D) X i = X j × El D X i
El (Arg A B) X i = Σ A (λ a → El (B a) X i)
\end{verbatim}

For example, below is the type that the {\tt cons} branch of
{\tt VecD} gets interpreted as. Precisely, this is the type returned
by {\tt El (VecC A consT) (Vec A) n}.

\begin{verbatim}
Σ ℕ (λ m → A × Vec A m × (suc m ≡ n))
\end{verbatim}

Dependent arguments {\tt Arg} and recursive arguments
{\tt Rec} get interpreted respectively as dependent pair
{\tt Σ} and non-dependent pair {\tt (×)}. The end of a constructor
{\tt End} gets interpreted as a proposition that the index that the
type is interpreted as is equal to the index that the constructor was
defined to be.

\subsection{First-class Enumerations \& Tags}

When defining the description of vectors, we previously used a custom
tag type {\tt VecT} to name each constructor. Descriptions are
primarily meant as a construction for representing user-defined
datatypes in a dependent type theory with a closed universe of types.
To prevent the need to extend the type theory with new tag types
constantly, we can instead define first-class enumerations and tags.
Enumerations are just a list of labels. A tag is an index into an
enumeration, pointing at a specific label.

\begin{verbatim}
Label : Set
Label = String

Enum : Set
Enum = List Label

data Tag : Enum → Set where
  here : ∀{l E} → Tag (l ∷ E)
  there : ∀{l E} → Tag E → Tag (l ∷ E)
\end{verbatim}

A tag can be eliminated with a {\tt case} construct (known elsewhere as
{\tt switch}~\citep{Chapman:2010:GAL:1932681.1863547,dagand:phd}).
In addition to the tag being elimnated, the case construct is given a
list of branches.

\begin{verbatim}
case : {E : Enum} (P : Tag E → Set)
  (cs : Branches E P) (t : Tag E) → P t
case P (c , cs) here = c
case P (c , cs) (there t) =
  case (λ t → P (there t)) cs t
\end{verbatim}

There is a branch for each label in the enumeration, and the type of
each branch depends on the tag representing the position of the label
in the enumeration.

\begin{verbatim}
Branches : (E : Enum) (P : Tag E → Set) → Set
Branches [] P = ⊤
Branches (l ∷ E) P =
  P here × Branches E (λ t → P (there t))
\end{verbatim}

The only definitions we need to change are to replace
{\tt VecT} with an {\tt Enum}, and to define
{\tt VecC} in terms of the {\tt case} eliminator rather than
by pattern matching. Note that a right-nested product of
{\tt Branches} always ends in the unit type {\tt ⊤}.

\begin{verbatim}
VecT : Enum
VecT = "nil" ∷ "cons" ∷ []

VecC : (A : Set) → Tag VecT → Desc ℕ
VecC A = caseD $
    End zero
  , Arg ℕ (λ n → Arg A (λ _ → Rec n (End (suc n))))
  , tt
\end{verbatim}



\section{Functions using {\tt ind}}
\label{sec:ind}

In Section \ref{sec:background} we looked at all the pieces involved
in introducing described datatypes. Now we will review how to
eliminate described datatypes using the primitive elimination
rule {\tt ind}. Function definitions that use {\tt ind} are verbose,
but we identify common elements shared between them. Removing
this duplication is the key to defining our generic eliminator
{\tt elim} in Section \ref{sec:elim}.

\todo[inline]{may be able to only explain ind and Hyps intuitively
after fold in terms of their types
section on implementing currying/uncurrying can go into details on
Hyps, Branches, etc

maybe do this by referencing a figure of Hyps}

\todo[inline]{following the intuition of mcbride ornaments, we 
first show fold over algebra and then ind
dagand algebra notation for dependent version}

\todo[inline]{
first show examples of both append and concat using elims
then in figures using ind
make these figures have numbers that point to the duplicated
sections}

\section{Functions using {\tt elim}}
\label{sec:elim}

\section{Currying and Uncurrying}
\label{sec:curry}

\todo[inline]{compare everything to respective simple haskell functions}

\section{Related Work}
\label{sec:related-work}

One alternative {\tt Desc} definition is that of \citet{dagand:phd}, which
allows datatypes to be defined as computations over their indices.
In this paper a sum of datatypes, representing multiple construtors,
is encoded as a dependent pair whose first index is a list of choices
of constructor names. An alternative way to encode datatypes is to
support sum types directly in descriptions and use those rather than
their isomorphic dependent pair equivalents. Foveran~\citep{foveran} is
an example of a language that encoded sum types directly.

\todo[inline]{cite generic/generic-algebras.pdf}

\acks

\todo[inline]{thank reviewers and mention nsf grant}

\bibliographystyle{abbrvnat}
\bibliography{generic-elim}

\end{document}
