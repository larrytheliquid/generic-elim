\documentclass[preprint,nonatbib]{sigplanconf}
\usepackage[authoryear,square]{natbib}

\usepackage{todonotes}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{url}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{stmaryrd}
\usepackage{enumitem}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{8759}{\ensuremath{\colon\colon}}
\DeclareUnicodeCharacter{12314}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{12315}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{8614}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{?}{=}}}

\DeclareUnicodeCharacter{7496}{\ensuremath{^{d}}}

\usepackage{fancyvrb}

\usepackage[labelfont=bf]{caption}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\titlebanner{DRAFT}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic Eliminators via Descriptions}
%% \subtitle{Curry Strikes Back}

\authorinfo{Larry Diehl\and Tim Sheard}
           {Portland State University}

\maketitle

\begin{abstract}
Sed pellentesque massa purus, ac aliquam ipsum auctor in. Mauris et
libero risus. In scelerisque neque vel odio tempus, commodo gravida
purus faucibus. Aliquam pharetra mauris consequat, gravida justo sed,
facilisis elit. Nullam enim ipsum, varius ut condimentum eget, tempor
id eros. Aenean id eros vestibulum, hendrerit dui eget, tincidunt
elit. Ut nec dignissim lectus, a bibendum turpis. Vivamus tincidunt
consequat ante. Suspendisse congue convallis ipsum vitae egestas. Ut
interdum elit id nunc aliquam lobortis.
\end{abstract}

\category{D.3}{Software}{Programming Languages}.

\keywords
Generic programming; dependent types; descriptions; eliminators.

\section{Introduction}
\label{sec:intro}

Descriptions make datatype definitions first class values in a
dependent type theory. This has several desirable consequences, such as the
ability to perform generic programming~\citep{Chapman:2010:GAL:1932681.1863547,mcbride2010ornamental,dagand:phd}
over described types, as well as decreasing the number of constructs in the
metatheory via levitation~\citep{Chapman:2010:GAL:1932681.1863547,dagand:phd}. 
Any type represented as a description can
be eliminated with {\tt ind}, which resembles a fold (or catamorphism) but
over indexed type families. Definitions written with {\tt ind} are
verbose but follow a recognizable pattern (Section \ref{TODO}). 
On the other hand, definitions written with {\it eliminators} (or
induction principles) are shorter and more common amongst type
theorists.

Now let's look at the type of {\tt ind}. Think of it almost like a standard
eliminator that has been parameterized over any description {\tt D} of a type. The
motive {\tt P} is indexed over the type family {\tt μ I D i}, which is
the datatype that description {\tt D} represents.
Here {\tt I} is the type of the index of the type family being
encoded, and {\tt i} is the value of the index whose type is {\tt I}.
The key difference
between {\tt ind} and a standard eliminator is that all branches for
each constructor of the encoded type are packaged into a single branch
{\tt pcon}. In order to prove that {\tt P} holds for any
{\tt μ I D i}, you get all constructors and all of their
arguments in {\tt xs}, along with all inductive
hypotheses {\tt ihs} for any recursive constructor arguments.

\newpage

\begin{verbatim}
ind :
  (I : Set)
  (D : Desc I)
  (P : (i : I) → μ I D i → Set)
  (pcon : (i : I) (xs : El I D X i)
    (ihs : Hyps I D X P i xs) → P i (con xs))
  (i : I) (x : μ I D i) → P i x
\end{verbatim}

Function definitions written with {\tt ind} are verbose
because they need to unpack all of the data supplied by {\tt pcon}.
Worse still, there are several ways to define the datatype of
descriptions {\tt Desc}, and several ways to encode datatypes once a
particular definition of {\tt Desc} has been chosen. This means that a
user wishing to program with datatypes encoded by descriptions must be
aware of how the encodings get interpreted so that they may
appropriately unpack data when writing functions with {\tt ind}.

For example, if we partially apply {\tt ind} to a description of a
vector of booleans {\tt ind ℕ (VecD Bool)} then the type of the
resulting expression depends both on how we defined {\tt Desc} and how
we encoded vectors as a description {\tt VecD}.

Rather than making the user learn our data format and suffer the
consequences of unpacking encoded data, our {\bf primary contribution} is
the definition of a {\it generic} eliminator {\tt elim}!
It assumes a particular way of encoding
datatypes via descriptions, and partial application of such a
description to {\tt elim} results in the expected type of eliminator.
For example, partial application of our previous example to
{\tt elim} results in the following type.

\begin{verbatim}
elim ℕ (VecD Bool) :
  (P : (n : ℕ) → Vec Bool n → Set)
  (pnil : P zero nil)
  (pcons : (n : ℕ) (x : Bool) (xs : Vec Bool n)
    → P n xs → P (suc n) (cons n x xs))
  (n : ℕ) (xs : Vec Bool n) → P n xs
\end{verbatim}

Our {\tt elim} function can be defined in terms of
{\tt ind}, making it another example of generic programming made
possible by descriptions.
Note that we are not generating specialized eliminators like
{\tt elimVec} à la {\sc Coq}, but instead have a single generic
{\tt elim} function that can be applied to any description of a
datatype.
Because this definition is internal to the
existing type theory, no additional metatheory needs to be proven.
Furthermore, there are several existing algorithms already defined in
terms of eliminators that can now be reused.
For example, \citet{gimenez1995codifying} translates
{\sc Coq}~\citeyearpar{coq08} {\tt Fix}-based definitions into eliminators,
and \citet{Goguen06eliminatingdependent} and
\citet{McBride:2000:EM:646540.759262}
translate dependent pattern matching into
eliminators. Rather than reinventing these algorithms to translate to
{\tt ind}, we can instead directly reuse them thanks to {\tt elim}.

\section{Background}
\label{sec:background}

We will begin with a review of the framework used to encode datatypes
via descriptions. In the introduction we mentioned that there are
several ways to define the datatype of descriptions {\tt Desc}, and
several ways to encode datatypes using descriptions. For simplicity,
in this paper we use the encoding by \citet{mcbride2010ornamental}. The related
work in Section \ref{sec:related-work} includes some alternative
encodings.

\subsection{Descriptions}



\section{Related Work}
\label{sec:related-work}

One alternative {\tt Desc} definition is that of \citet{dagand:phd}, which
allows datatypes to be defined as computations over their indices.
In this paper a sum of datatypes, representing multiple construtors,
is encoded as a dependent pair whose first index is a list of choices
of constructor names. An alternative way to encode datatypes is to
support sum types directly in descriptions and use those rather than
their isomorphic dependent pair equivalents. Foveran~\citep{foveran} is
an example of a language that encoded sum types directly.

\bibliographystyle{abbrvnat}
\bibliography{generic-elim}

\end{document}
