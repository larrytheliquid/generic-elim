\documentclass[preprint,nonatbib]{sigplanconf}
\usepackage[authoryear,square]{natbib}

\usepackage{todonotes}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{url}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{stmaryrd}
\usepackage{enumitem}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{8759}{\ensuremath{\colon\colon}}
\DeclareUnicodeCharacter{12314}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{12315}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{8614}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{?}{=}}}

\DeclareUnicodeCharacter{7496}{\ensuremath{^{d}}}

\usepackage{fancyvrb}

\usepackage[labelfont=bf]{caption}

\newtheorem{mydef}{Definition}
\newtheorem{myparte}{Part$_E$}
\newtheorem{myparti}{Part$_I$}

\newcommand{\refsec}[1]{Section \ref{sec:#1}}
\newcommand{\refparte}[1]{Part$_E$ \ref{parte:#1}}
\newcommand{\refparti}[1]{Part$_I$ \ref{parti:#1}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\titlebanner{DRAFT}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic Eliminators from Descriptions}
\subtitle{Dependently typed programming without the algebra}

\authorinfo{Larry Diehl\and Tim Sheard}
           {Portland State University}

\maketitle

\begin{abstract}
Sed pellentesque massa purus, ac aliquam ipsum auctor in. Mauris et
libero risus. In scelerisque neque vel odio tempus, commodo gravida
purus faucibus. Aliquam pharetra mauris consequat, gravida justo sed,
facilisis elit. Nullam enim ipsum, varius ut condimentum eget, tempor
id eros. Aenean id eros vestibulum, hendrerit dui eget, tincidunt
elit. Ut nec dignissim lectus, a bibendum turpis. Vivamus tincidunt
consequat ante. Suspendisse congue convallis ipsum vitae egestas. Ut
interdum elit id nunc aliquam lobortis.
\end{abstract}

\category{D.3}{Software}{Programming Languages}.

\keywords
Generic programming; dependent types; descriptions; eliminators.

\section{Introduction}
\label{sec:intro}

Descriptions make datatype definitions first class values in a
dependent type theory. This has several desirable consequences, such as the
ability to perform generic programming~\citep{Chapman:2010:GAL:1932681.1863547,mcbride2010ornamental,dagand:phd}
over described types, as well as decreasing the number of constructs in the
metatheory via levitation~\citep{Chapman:2010:GAL:1932681.1863547,dagand:phd}. 
Any type represented as a description can
be eliminated with its elimination rule -- called {\tt ind} -- which resembles a fold (or catamorphism) but
over indexed type families. Functions written with {\tt ind} are
verbose but follow a recognizable pattern (\refsec{ind}). 
On the other hand, functions written with standard {\it eliminators} (or
induction principles) are shorter and more widely understood.

Now let's look at the type of {\tt ind}. Think of it almost like a standard
eliminator that has been parameterized over any description {\tt D} of a type. The
motive {\tt P} is indexed over the type family {\tt μ I D i}, which is
the datatype that description {\tt D} represents.
Here {\tt I} is the type of the index of the type family being
encoded, and {\tt i} is the value of the index whose type is {\tt I}.
The key difference
between {\tt ind} and a standard eliminator is that all branches for
each constructor of the encoded type are packaged into a single branch
{\tt α}. In order to prove that {\tt P} holds for any
{\tt μ I D i}, you get all constructors and all of their
arguments in {\tt xs}, along with all inductive
hypotheses {\tt ihs} for any recursive constructor arguments.

\newpage

\begin{verbatim}
ind : {I : Set} (D : Desc I)
  (P : (i : I) → μ D i → Set)
  (α : Hyps D X P ⇒ P ∘ init)
  (i : I) (x : μ D i) → P i x
\end{verbatim}

Function definitions written with {\tt ind} are verbose
because they need to unpack all of the data supplied by {\tt α}.
Worse still, there are several ways to define the datatype of
descriptions {\tt Desc}, and several ways to encode datatypes once a
particular definition of {\tt Desc} has been chosen. This means that a
user wishing to program with datatypes encoded by descriptions must be
aware of how the encodings get interpreted so that they may
appropriately unpack data when writing functions with {\tt ind}.

For example, if we partially apply {\tt ind} to a description of a
vector of booleans {\tt ind ℕ (VecD Bool)} then the type of the
resulting expression depends both on how we defined {\tt Desc} and how
we encoded vectors as a description {\tt VecD}.

Rather than making the user learn our data format and suffer the
consequences of unpacking encoded data, our {\bf primary contribution} is
the definition of a {\it generic} eliminator {\tt elim}!
It assumes a particular way of encoding
datatypes via descriptions, and partial application of such a
description to {\tt elim} results in the expected type of eliminator.
For example, partial application of our previous example to
{\tt elim} results in the following type.

\begin{verbatim}
elim ℕ (VecD Bool) :
  (P : (n : ℕ) → Vec Bool n → Set)
  (pnil : P zero nil)
  (pcons : (n : ℕ) (x : Bool) (xs : Vec Bool n)
    → P n xs → P (suc n) (cons n x xs))
  (n : ℕ) (xs : Vec Bool n) → P n xs
\end{verbatim}

Our {\tt elim} function can be defined in terms of
{\tt ind}, making it another example of generic programming made
possible by descriptions.
Note that we are not generating specialized eliminators like
{\tt elimVec} à la {\sc Coq}, but instead have a single generic
{\tt elim} function that can be applied to any description of a
datatype.
Because this definition is internal to the
existing type theory, no additional metatheory needs to be proven.
Furthermore, there are several existing algorithms already defined in
terms of eliminators that can now be reused.
For example, \citet{gimenez1995codifying} translates
{\sc Coq}~\citeyearpar{coq08} {\tt Fix}-based definitions into eliminators,
and \citet{Goguen06eliminatingdependent} and
\citet{McBride:2000:EM:646540.759262}
translate dependent pattern matching into
eliminators. Rather than reinventing these algorithms to translate to
{\tt ind}, we can instead directly reuse them with our derived {\tt elim}.

\section{Background}
\label{sec:background}

We will begin with a review of the framework used to encode datatypes
via descriptions. There are
several ways to define the datatype of descriptions {\tt Desc}. 
For simplicity, in this paper we use the encoding by
\citet{mcbride2010ornamental}.

\subsection{The Type of Descriptions}

The datatype {\tt Desc} of descriptions is used to represent
user-defined definitions of strictly-positive indexed
families of inductively defined types.
{\tt Desc} is paramterized by 
a type {\tt I}, the index of the encoded type family.

Let's first think about how to use {\tt Desc} to encode a single
constructor of an indexed type family.
A constructor is a sequence of
arguments that subsequent arguments may depend on, along with
recursive arguments at some type indices, and ends with some type index.
Respectively, {\tt Arg}, {\tt Rec}, and {\tt End} allow you to encode
a dependent argument, a recursive argument at some index, and ending the
constructor at some index.

\begin{verbatim}
data Desc (I : Set) : Set₁ where
  End : (i : I) → Desc I
  Rec : (i : I) (D : Desc I) → Desc I
  Arg : (A : Set) (B : A → Desc I) → Desc I
\end{verbatim}

\subsection{Describing a Single Constructor}

For example, first recall the standard type of the
constructor {\tt cons} of vectors.

\begin{verbatim}
cons : (n : ℕ) → A → Vec A n → Vec A (suc n)
\end{verbatim}

We can encode the type of this constructor as a description as
follows. The definition is parameterized by the vector parameter
type {\tt A}, and returns a description over natural numbers
{\tt Desc ℕ} because the type we are encoding {\tt Vec}
is indexed by natural numbers.

\begin{verbatim}
consD : (A : Set) → Desc ℕ
consD A =
  Arg ℕ (λ n → Arg A (λ _ → Rec n (End (suc n))))
\end{verbatim}

\subsection{Describing Multiple Constructors}
\label{sec:background:multiple}

The datatype {\tt Desc} can also be used to describe an entire
datatype, consisting of descriptions of multiple constructors.
This is achieved by making use of the isomorphism between disjoint
sums and dependent pairs whose domain is some finite enumeration.

A datatype with multiple constructors is represented by an
{\tt Arg} description whose first argument is a datatype of tags
-- one for each constructor -- and whose second argument is
a function that returns a description for each constructor tag.

\begin{verbatim}
data VecT : Set where
  nilT consT : VecT

VecC : (A : Set) → VecT → Desc ℕ
VecC A nilT = End zero
VecC A consT =
  Arg ℕ (λ n → Arg A (λ _ → Rec n (End (suc n))))

VecD : (A : Set) → Desc ℕ
VecD A = Arg VecT (VecC A)
\end{verbatim}

Notice that our previous description of the {\tt cons} constructor,
{\tt consD A}, is equal to the tagged description
{\tt VecC A consT}.

\subsection{Datatypes from Descriptions}

Now that we can encode datatypes as descriptions, we will see how to
convert a description into a full datatype. You get such a datatype by
applying the fixpoint type {\tt μ} to a description.
The constructor {\tt init}
for {\tt μ} is the initial algebra of the description interpreted as
an endofunctor on indexed families of sets.

\begin{verbatim}
data μ {I : Set} (D : Desc I) (i : I) : Set where
  init : El D (μ D) i → μ D i
\end{verbatim}

For example, we can define the datatype {\tt Vec} by applying
{\tt μ} to its description.

\begin{verbatim}
Vec : (A : Set) (n : ℕ) → Set
Vec A n = μ (VecD A) n
\end{verbatim}

\subsection{Endofunctors from Descriptions}

The constructor for {\tt μ} takes an argument of type {\tt El}.
This is a function that when given a description computes an
endofunctor between type families. Below, {\tt ISet} is the type of
type families, and {\tt IFunc} is the endofunctor type.

\begin{verbatim}
ISet : Set → Set₁
ISet I = I → Set

IFunc : Set → Set₁
IFunc I = ISet I → ISet I
\end{verbatim}

\begin{mydef}\label{def:el}
Endofunctor

\begin{verbatim}
El : {I : Set} (D : Desc I) → IFunc I
El (End j) X i = j ≡ i
El (Rec j D) X i = X j × El D X i
El (Arg A B) X i = Σ A (λ a → El (B a) X i)
\end{verbatim}

\end{mydef}

For example, below is the type that the {\tt cons} branch of
{\tt VecD} gets interpreted as. Precisely, this is the type returned
by {\tt El (VecC A consT) (Vec A) n}.

\begin{verbatim}
Σ ℕ (λ m → A × Vec A m × (suc m ≡ n))
\end{verbatim}

Dependent arguments {\tt Arg} and recursive arguments
{\tt Rec} get interpreted respectively as dependent pair
{\tt Σ} and non-dependent pair {\tt (×)}. The end of a constructor
{\tt End} gets interpreted as a proposition that the index that the
type is interpreted as is equal to the index that the constructor was
defined to be.

\subsection{First-class Enumerations \& Tags}
\label{sec:background:case}

When defining the description of vectors, we previously used a custom
tag type {\tt VecT} to name each constructor. Descriptions are
primarily meant as a construction for representing user-defined
datatypes in a dependent type theory with a closed universe of types.
To prevent the need to extend the type theory with new tag types
constantly, we can instead define first-class enumerations and tags.
Enumerations are just a list of labels. A tag is an index into an
enumeration, pointing at a specific label.

\begin{verbatim}
Label : Set
Label = String

Enum : Set
Enum = List Label

data Tag : Enum → Set where
  here : ∀{l E} → Tag (l ∷ E)
  there : ∀{l E} → Tag E → Tag (l ∷ E)
\end{verbatim}

A tag can be eliminated with a {\tt case} construct (known elsewhere as
{\tt switch}~\citep{Chapman:2010:GAL:1932681.1863547,dagand:phd}).
In addition to the tag being elimnated, the case construct is given a
list of branches.

\begin{verbatim}
case : {E : Enum} (P : Tag E → Set)
  (cs : Branches E P) (t : Tag E) → P t
case P (c , cs) here = c
case P (c , cs) (there t) =
  case (λ t → P (there t)) cs t
\end{verbatim}

There is a branch for each label in the enumeration, and the type of
each branch depends on the tag representing the position of the label
in the enumeration.

\begin{mydef}\label{def:branches}
Branches of a case-statement for tags

\begin{verbatim}
Branches : (E : Enum) (P : Tag E → Set) → Set
Branches [] P = ⊤
Branches (l ∷ E) P =
  P here × Branches E (λ t → P (there t))
\end{verbatim}

\end{mydef}

The only definitions we need to change are to replace
{\tt VecT} with an {\tt Enum}, and to define
{\tt VecC} in terms of the {\tt case} eliminator rather than
by pattern matching. Note that a right-nested product of
{\tt Branches} always ends in the unit type {\tt ⊤}.

\begin{verbatim}
VecT : Enum
VecT = "nil" ∷ "cons" ∷ []

VecC : (A : Set) → Tag VecT → Desc ℕ
VecC A = caseD $
    End zero
  , Arg ℕ (λ n → Arg A (λ _ → Rec n (End (suc n))))
  , tt
\end{verbatim}

\subsection{Examples using Specialized Eliminators}
\label{sec:background:elim}

Below is a review of standard eliminators and how to define functions
with them. If you are already comfortable with this, you still may
find it useful to compare the examples below with the more complex
definitions in \refsec{ind}.

The {\tt concat} functions flattens a vector of vectors,
each of which is equal in length. The second argument to {\tt elimVec}
is the motive, which allows the return type to depend on the vector
being eliminated and its index. In this simple example, the motive is
the same type as the return type of {\tt concat}. After the motive
comes a branch for each constructor of the type being eliminated. For
{\tt Vec}, the first branch is the {\tt nil} case and the second
branch is the {\tt cons} case. If a constructor has arguments, its
corresponding branch takes a function that binds each of the
arguments. Finally, after each recursive argument you also get the
inductive hypothesis. Below, the first branch simply returns
{\tt nil} to concatenate the empty vector. The second branch
returns the result of appending the current nested vector with
the induction hypothesis (the recursive call). Also notice that we
do not supply the eliminated vector explicitly, and instead partially
apply {\tt elimVec} to our arguments.

\begin{verbatim}
concat : (A : Set)
  (m n : ℕ)
  (xss : Vec (Vec A m) n)
  → Vec A (mult n m)
concat A m = elimVec (Vec A m)
  (λ n xss → Vec A (mult n m))
  nil
  (λ n xs xss ih → append A m xs (mult n m) ih)
\end{verbatim}

Next we define the {\tt append} function, which combines two vectors
together. Append is also defined by partially applying
{\tt elimVec}, but the index and vector being eliminated are
the first arguments {\tt m} and {\tt xs} in the type signature.
Because we are left with the remaining arguments {\tt n} and 
{\tt ys}, our motive needs to include them. Notice how the motive is
supplied {\tt m} and {\tt xs} as arguments, but returns {\tt n} and
{\tt ys} as {\tt Π} types. Because of this, now the {\tt nil} branch
binds the remaining arguments {\tt n} and {\tt ys} instead of being
empty. The {\tt cons} branch also binds the extra arguments.
Furthermore, the inductive hypothesis now takes two arguments because
the type that the motive returns is a function type!

\begin{verbatim}
append : (A : Set)
  (m : ℕ) (xs : Vec A m)
  (n : ℕ) (ys : Vec A n)
  → Vec A (add m n)
append A = elimVec A
  (λ m xs →
    (n : ℕ) (ys : Vec A n) → Vec A (add m n))
  (λ n ys → ys)
  (λ m x xs ih n ys → cons (add m n) x (ih n ys))
\end{verbatim}

Eliminators always follow a certain structure. The first arguments are
the type parameters of the type being eliminated. Next is the motive,
which is a type family indexed by the type being eliminated and its
indices. Next come a branch for each constructor in the eliminated
type. Each branch binds the arguments of the constructor and the
motive instantiated to recursive arguments. Finally, the type of the
eliminator takes the type being eliminated and its indices and returns
the motive applied to the eliminated type. \citet{paulin1993inductive}
gives a formal account of eliminator structure, used to specify
inductive definitions in {\sc Coq}.

\section{Programming with Algebras}
\label{sec:ind}

In \refsec{background} we looked at all the pieces involved
in introducing described datatypes. Now we will review how to
eliminate described datatypes using the primitive elimination
rule {\tt ind}. Function definitions that use {\tt ind} are verbose,
but we identify common elements shared between them. Removing
this duplication is the key to defining our generic eliminator
{\tt elim} in \ref{elim}.

\subsection{The Type of {\tt ind}}

In the introduction we presented a sugared type signature of
{\tt ind}. Following \citet{dagand:phd}, we emphasized
the categorical nature of the algebra argument
{\tt α : Hyps D X P ⇒ P ∘ init}. 
This argument appears below in its desugared form.

\begin{verbatim}
ind : {I : Set} (D : Desc I)
  (P : (i : I) → μ D i → Set)
  (α : ∀ i → (xs : El D (μ D) i)
    (ihs : Hyps D (μ D) P i xs) → P i (init xs))
  (i : I) (x : μ D i) → P i x
\end{verbatim}

The arrow {\tt (⇒)} is notation for an index-preserving function
between families of sets indexed by
{\tt ∀ i → (xs : El D (μ D) i)}.
In the expanded form, we can recognize {\tt ind} as an induction
principle. In order to prove {\tt P} for any {\tt μ D i},
we prove that it holds for any subterm by supplying the function
{\tt α}.
Recall that {\tt init} has type {\tt El D (μ D) i → μ D i}.
All of the constructors and arguments are packaged up in
{\tt El D (μ D) i}, which we are given as an argument to
{\tt α}. The inductive hypotheses for each constructor are simililarly
packaged up in {\tt Hyps D (μ D) P i xs} and given as an argument to 
{\tt α}. Thus, all the ``branch'' arguments of a regular eliminator
are replaced by the single algebra {\tt α}.

\subsection{Inductive Hypotheses from Descriptions}

The type of inductive hypotheses {\tt Hyps} for a described datatype
is very similiar to the definition of endofunctor {\tt El} for
described types. The definition of {\tt Hyps} crawls the structure of
descriptions. It ignores any dependent arguments and demands the
motive applied to subterm indices for recursive arguments.

\begin{mydef}\label{def:hyps}
Inductive Hypotheses

\begin{verbatim}
Hyps : {I : Set} (D : Desc I) (X : ISet I)
  (P : (i : I) → X i → Set)
  (i : I) (xs : El D X i) → Set
Hyps (End j) X P i q = ⊤
Hyps (Rec j D) X P i (x , xs) =
  P j x × Hyps D X P i xs
Hyps (Arg A B) X P i (a , b) = Hyps (B a) X P i b
\end{verbatim}

\end{mydef}

\subsection{Examples using {\tt ind}}

Now let's take a look at functions over types built with descriptions
and eliminated with {\tt ind}. Definitions for the vector functions
{\tt concat} and {\tt append} appear respectively in
Figure \ref{fig:ind:concat} and Figure \ref{fig:ind:append}. These
functions have quite a lot going on, so you might like to compare them with
simpler versions defined in terms of eliminators in
\refsec{background:elim}.

In languages like
{\sc Agda}~\citep{norell2007towards},
{\sc Coq}~\citep{coq08}, and
{\sc Idris}~\citep{brady2011idris} users define
datatypes as a sum (the constructors) of products (their arguments),
along with the specification of indices for recursive arguments and at
the end of each constructor. Defining a function using {\tt ind} over
such types consists of 4 steps. The numbers of the subsections below
correspond with the numbers in
the code appearing in Figure \ref{fig:ind:concat} and
Figure \ref{fig:ind:append}.

\begin{myparte}[Eliminating using {\tt ind}]
\label{parte:one}
A definition begins by using {\tt ind} to eliminate a particular
argument of the function. The motive supplied to {\tt ind} is the same
that would be given for an eliminator-based definition.
\end{myparte}


\begin{myparte}[Breaking up Constructors into Branches]
\label{parte:two}
Next comes the main part of the function definition, which is the
algebra argument {\tt α}. In an eliminator-based definition we would
supply branches for each constructor. Here we the index, all
constructors, and all their inductive hypotheses packaged as a single
argument. We use {\tt case} from
\refsec{background:case} so that we can supply separate branches, one
for each constructor. A sum of constructors is represented
using a dependent pair (
\refsec{background:multiple}), and the convoy
pattern~\citep{TODO} lets us access the arguments of the constructor
(the second component of the pair) by case analyzing the
constructor {\tt Tag} (the first component of the pair).
\end{myparte}

\begin{myparte}[Projecting Arguments and Inductive Hypotheses]
\label{parte:three}
Each branch gets two arguments. The first is a tuple of all
constructor arguments. This tuple ends with an equality proof
indicating the value of the index of the constructor. For example,
{\tt m ≡ suc n} for the {\tt cons} branch. The second branch argument
is a tuple of all inductive hypotheses. This tuple ends with a value
of type unit. In order to use any constructor arguments or inductive
hypotheses, we must project them out of a tuple.
\end{myparte}

\begin{myparte}[Coercing Constructor Indices]
\label{parte:four}
Functions returning a value of a type family require that value to
inhabit a particular index. For example, we expect to return the zero
length vector {\tt nil} in the first branch of {\tt concat}.
However, by default the branch still expects a value of type
{\tt Vec A (mult n m)} where {\tt n} is the index of the vector being
eliminated. In order for {\tt mult n m} to reduce, we must coerce {\tt n}
to be zero by applying {\tt subst} to a proof of {\tt n ≡ zero}. This
is the equality proof that appears at the end of the tuple of
arguments for each constructor.
\end{myparte}


\begin{figure*}
\caption{Definition of vector {\tt concat} using {\tt ind}.}
\label{fig:ind:concat}

\begin{verbatim}
concat : (A : Set) (m n : ℕ) (xss : Vec (Vec A m) n) → Vec A (mult n m)
concat A m = ind (VecD (Vec A m))                              -- # 1
  (λ n xss → Vec A (mult n m))
  (λ n t,c → case                                              -- # 2
    (λ t → (c : El (VecC (Vec A m) t) (Vec (Vec A m)) n)
           (ih : Hyps (VecD (Vec A m)) (Vec (Vec A m)) (λ n xss → Vec A (mult n m)) n (t , c))
           → Vec A (mult n m)
    )
    ( (λ q ih → subst (λ n → Vec A (mult n m)) q (nil A))     -- # 4
    , (λ n',xs,xss,q ih,tt →                                  -- # 3
        let n' = proj₁ n',xs,xss,q
            xs = proj₁ (proj₂ n',xs,xss,q)
            q = proj₂ (proj₂ (proj₂ n',xs,xss,q))
            ih = proj₁ ih,tt
        in                                                     -- # 4
        subst (λ n → Vec A (mult n m)) q (append A m xs (mult n' m) ih)
      )
    , tt
    )
    (proj₁ t,c)
    (proj₂ t,c)
  )
\end{verbatim}

\end{figure*}

\begin{figure*}
\caption{Definition of vector {\tt append} using {\tt ind}.}
\label{fig:ind:append}

\begin{verbatim}
append : (A : Set) (m : ℕ) (xs : Vec A m) (n : ℕ) (ys : Vec A n) → Vec A (add m n) 
append A = ind (VecD A)                                         -- # 1
  (λ m xs → (n : ℕ) (ys : Vec A n) → Vec A (add m n)) 
  (λ m t,c → case                                               -- # 2
    (λ t → (c : El (VecC A t) (Vec A) m)
           (ih : Hyps (VecD A) (Vec A) (λ m xs → (n : ℕ) (ys : Vec A n) → Vec A (add m n)) m (t , c))
           (n : ℕ) (ys : Vec A n) → Vec A (add m n)
    )
    ( (λ q ih n ys → subst (λ m → Vec A (add m n)) q ys)       -- # 4
    , (λ m',x,xs,q ih,tt n ys →                                -- # 3
        let m' = proj₁ m',x,xs,q
            x = proj₁ (proj₂ m',x,xs,q)
            q = proj₂ (proj₂ (proj₂ m',x,xs,q))
            ih = proj₁ ih,tt
        in                                                      -- # 4
        subst (λ m → Vec A (add m n)) q (cons A (add m' n) x (ih n ys))
      )
    , tt
    )
    (proj₁ t,c)
    (proj₂ t,c)
  )
\end{verbatim}

\end{figure*}

\section{Defining Generic Eliminators}
\label{sec:elim}

In \refsec{ind} we looked at examples of functions defined
with {\tt ind}, and how each such definition can be broken up into 4
parts. Now we will systematically derive new induction principles,
each building on the next, that implements some of the 4 parts. The
final induction principle will be the generic eliminator {\tt elim}
that is the primary contribution of this paper. 

Throughout this section we will refer to curried versions of
definitions given elsewhere in the paper. The definitions for these
curried versions appear in \refsec{curry}.

\subsection{Curried {\tt ind}}

First let's recall the type of the algebra argument for {\tt ind}.

\begin{verbatim}
(α : ∀ i
    (xs : El D (μ D) i)
    (ihs : Hyps D (μ D) P i xs)
    → P i (init xs))
\end{verbatim}

You can think of this like an uncurried function of type
{\tt (A × B) → (C × D) → X}. Here {\tt xs} corresponds to uncurried
argument {\tt (A × B)}, {\tt ihs} corresponds to {\tt C × D}, and 
{\tt P i (init xs)} corresponds to the return type {\tt X}.

We can implement a function like {\tt ind} that takes a curried
version of the algebra argument instead. The {\tt CurriedAlg} argument
(defined in \refsec{curry}) represents the curried function
{\tt A → B → C → D → X}.

\begin{verbatim}
indCurried : {I : Set} (D : Desc I)
  (P : (i : I) → μ D i → Set)
  (α : CurriedAlg D (μ D) P init)
  (i : I)
  (x : μ D i)
  → P i x
indCurried D P α i x =
  ind D P (uncurryAlg D (μ D) P init α) i x
\end{verbatim}

The {\tt indCurried} functions implements 3 of the 4 parts of our
pattern. It starts off the definition with {\tt ind}
(\refparte{one}) and it implicitly projects arguments and inductive
hypotheses by using a curried {\tt α} argument
(\refparte{three}). Although it isn't obvious here, we will see
in \refsec{curry} that {\tt CurriedAlg} also implicitly
coerces constructor indices (\refparte{four}).

\subsection{Uncurried {\tt elim}}

To implement \refparte{two} we need to break up a sum of
constructors into branches, one for each constructor. Recall that the
shape of datatypes built out of descrptions that we would like to
eliminate is a sum of products. To capture this, our new induction
principle is specialied to descriptions representing a sum of
products. This is achieved by parameterizing not by any description,
but by an {\tt E : Enum} and a function {\tt C} from tags of that enumeration to
descriptions representing the constructor choices. We can use these
pieces to build a description starting with {\tt Arg}, as seen in the
{\tt let} construct below. Finally, \refparte{two} is implemented
by performing {\tt case} analysis in the body of {\tt ind}.

\begin{verbatim}
elimUncurried : {I : Set} (E : Enum) (C : Tag E → Desc I)
  → let D = Arg (Tag E) C in
  (P : (i : I) → μ D i → Set)
  → UncurriedBranches E
  (λ t → CurriedAlg (C t) (μ D) P (λ xs → init (t , xs)))
  ((i : I) (x : μ D i) → P i x)
elimUncurried E C P cs i x =
  let D = Arg (Tag E) C in
  indCurried D P
    (case (λ t →
      CurriedAlg (C t) (μ D) P (λ xs → init (t , xs)))
      cs)
    i x
\end{verbatim}

Here, {\tt UncurriedBranches} is just a type synonym for a function
from {\tt Branches E P} to some result type {\tt X}.
It's definition can
be found in \refsec{curry}. 
Above {\tt P} is
the {\tt CurriedAlg} argument, and {\tt X} is
{\tt (i : I) (x : μ D i) → P i x}.

\subsection{Curried {\tt elim}}

Although we have technically implemented all four parts of our
pattern, the induction principle {\tt elimUncurried} isn't quite what
we want. The ``uncurried'' part of the name of the function refers to
the {\tt Branches} argument.
{\tt UncurriedBranches} is similar to the function
{\tt A × B → X}. Just like we did in {\tt indCurried}, we can define
our final generic eliminator {\tt elim} by returning
{\tt CurriedBranches} instead of {\tt UncurriedBranches}. Here
{\tt CurriedBranches} is analogous to {\tt A → B → X}.

\begin{verbatim}
  elim : {I : Set} (E : Enum) (C : Tag E → Desc I)
    → let D = Arg (Tag E) C in
    (P : (i : I) → μ D i → Set)
    → CurriedBranches E
    (λ t → CurriedAlg (C t) (μ D) P
      (λ xs → init (t , xs)))
    ((i : I) (x : μ D i) → P i x)
  elim E C P = curryBranches (elimUncurried E C P)
\end{verbatim}

Why do we need to do this? Recall that eliminators take a sequence of
branch arguments, one for each constructor. The type of
{\tt elimUncurried} is almost like a generic eliminator, except it
takes all branch arguments as a tuple (because that's what {\tt case}
takes), rather than taking a sequence of curried arguments. Thus, by
currying these branches we arrive at our final desired definition of
{\tt elim}.

Finally, we should point out that we gave separate definitions, each
building upon the previous, for pedagogical reaons. Of course, {\tt elim}
can be defined in one go by inlining the other definitions.

\section{Defining Generic Constructors}
\label{sec:init}

The opposite of eliminating values is introducing, or constructing,
values. A value of type built from a description is constructed using
the initial algebra constructor {\tt init} of {\tt μ}. Recall that the
type of {\tt init} is {\tt El D (μ D) i → μ D i}. When eliminating a
datatype with {\tt ind} you get an algebra with {\tt El D (μ D) i} as
an argument. Any arguments of constructors contained therein have
product types and  must be projected out.
Constructing a value also uses an algebra, the initial
one! Thus, to construct a value you need to pass it a tuple of
arguments.

\subsection{Examples using {\tt init}}

For example, below is a specialized constructor {\tt cons}
of vectors.

\begin{verbatim}
cons : (n : ℕ) → A → Vec A n → Vec A (suc n)
cons A n x xs = init (consT , n , x , xs , refl)
\end{verbatim}

To construct the vector, use init and pass it a tuple
starting with the named tag of the constructor, followed by all of its
arguments, and ending with a proof that it has the correct
index value.

\section{Currying and Uncurrying}
\label{sec:curry}

\todo[inline]{compare everything to respective simple haskell functions}

\section{Related Work}
\label{sec:related-work}

One alternative {\tt Desc} definition is that of \citet{dagand:phd}, which
allows datatypes to be defined as computations over their indices.
In this paper a sum of datatypes, representing multiple construtors,
is encoded as a dependent pair whose first index is a list of choices
of constructor names. An alternative way to encode datatypes is to
support sum types directly in descriptions and use those rather than
their isomorphic dependent pair equivalents. Foveran~\citep{foveran} is
an example of a language that encoded sum types directly.

\todo[inline]{cite generic/generic-algebras.pdf}

\clearpage

\acks

\todo[inline]{thank reviewers and mention nsf grant}

\bibliographystyle{abbrvnat}
\bibliography{generic-elim}

\end{document}
